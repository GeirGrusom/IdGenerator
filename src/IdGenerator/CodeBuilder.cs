using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Linq;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Text;

[assembly: InternalsVisibleTo("IdGenerator.Tests")]

namespace IxSoftware.Generators
{
    internal static class CodeBuilder
    {

        public static void AddPreamble(this StringBuilder builder, INamedTypeSymbol symbol, StructInfo structInfo)
        {
            builder.AppendLine($@"// This file was generated by a tool. Changes may be overwritten.

namespace {symbol.ContainingNamespace}
{{  
    public readonly partial struct {structInfo.Identifier}
    {{");

        }

        public static void AddConstructor(this StringBuilder builder, string typeName, StructInfo structInfo)
        {
            builder.AppendLine(@$"
        private {structInfo.Identifier}({typeName} value)
        {{
            this.{structInfo.Value} = value;
        }}

        public static explicit operator {typeName}({structInfo.Identifier} value) => value.{structInfo.Value};

        public static implicit operator {structInfo.Identifier}({typeName} value)
        {{{(structInfo.Validation == Validation.ValidateBool ?
            $@"
            var result = new {structInfo.Identifier}(value);
            return result.Validate() ? result : throw new global::System.ArgumentException(nameof(value));
" : $@"
            return new {structInfo.Identifier}(value);")}
        }}");
        }

        public static void AddEquals(this StringBuilder builder, string typeName, bool isNullableEnabled, bool isReferenceType, StructInfo structInfo)
        {
            if (IsString(typeName))
            {
                builder.AppendLine(@$"        public bool Equals({structInfo.Identifier} other) => global::System.String.Equals(this.{structInfo.Value}, other.{structInfo.Value}, global::System.StringComparison.Ordinal);");
            }
            else
            {
                if (isReferenceType)
                {
                    builder.AppendLine($@"        public bool Equals({structInfo.Identifier} other) => global::System.Object.Equals(this.{structInfo.Value}, other.{structInfo.Value});");
                }
                else
                {
                    builder.AppendLine($@"        public bool Equals({structInfo.Identifier} other) => this.{structInfo.Value}.Equals(other.{structInfo.Value});");
                }
            }

            string equalsType = isNullableEnabled ? "object?" : "object";

            builder.Append(@$"

        public override bool Equals({equalsType} obj)
        {{
");

            if(isReferenceType)
            {
                builder.Append($@"            if(obj is null) return false;
");
            }

            builder.Append(@$"
            if(obj is {structInfo.Identifier} other)
            {{
                return this.Equals(other);
            }}

            return false;
        }}
");
            if (isReferenceType)
            {
                builder.Append($@"
        public override int GetHashCode() => this.{structInfo.Value} is null ? 0 : this.{structInfo.Value}.GetHashCode();
");                
            }

            else
            {
                builder.Append($@"
        public override int GetHashCode() => this.{structInfo.Value}.GetHashCode();
");
            }

            builder.Append($@"

        public static bool operator ==({structInfo.Identifier} lhs, {structInfo.Identifier} rhs) => lhs.Equals(rhs);

        public static bool operator !=({structInfo.Identifier} lhs, {structInfo.Identifier} rhs) => !lhs.Equals(rhs);
");

        }

        public static void AddComparison(this StringBuilder builder, StructInfo structInfo)
        {
            builder.AppendLine($@"
        public int CompareTo({structInfo.Identifier} other) => global::System.Collections.Generic.Comparer<{structInfo.ValueType}>.Default.Compare(this.{structInfo.Value}, other.{structInfo.Value});
        
        public static bool operator >({structInfo.Identifier} lhs, {structInfo.Identifier} rhs) => lhs.{structInfo.Value} > rhs.{structInfo.Value};
    
        public static bool operator >=({structInfo.Identifier} lhs, {structInfo.Identifier} rhs) => lhs.{structInfo.Value} >= rhs.{structInfo.Value};

        public static bool operator <({structInfo.Identifier} lhs, {structInfo.Identifier} rhs) => lhs.{structInfo.Value} < rhs.{structInfo.Value};
        
        public static bool operator <=({structInfo.Identifier} lhs, {structInfo.Identifier} rhs) => lhs.{structInfo.Value} <= rhs.{structInfo.Value};
");
        }

        public static void AddEndOfFile(this StringBuilder builder)
        {
            builder.AppendLine(@"
    }
}");
        }

        public static void AddToString(this StringBuilder builder, string typeName, StructInfo structInfo)
        {
            if (string.Equals(typeName, "global::System.DateTime") || string.Equals(typeName, "global::System.DateTimeOffset"))
            {
                // Use ISO 8601 for date times so we don't end up with the idiotic US date format which for whatever crazy reason is what InvariantCulture uses in .NET.
                builder.AppendLine($@"        public override string ToString() => ((global::System.FormattableString)$""{{{structInfo.Value}:o}}"").ToString(global::System.Globalization.CultureInfo.InvariantCulture);");
            }
            else
            {
                builder.AppendLine($@"        public override string ToString() => ((global::System.FormattableString)$""{{{structInfo.Value}}}"").ToString(global::System.Globalization.CultureInfo.InvariantCulture);");
            }
        }

        public static string? MakeTypeName(TypeSyntax type, SemanticModel semanticModel)
        {
            if (type is TupleTypeSyntax tupleType)
            {
                return MakeTupleTypeName(semanticModel, tupleType);
            }
            else
            {
                var typeSymbol = semanticModel.GetSymbolInfo(type);
                if (typeSymbol.Symbol is null)
                {
                    return null;
                }
                
                if(type is GenericNameSyntax genericName)
                {
                    return $"global::{typeSymbol.Symbol.ContainingNamespace}.{typeSymbol.Symbol.Name}<{string.Join(", ", genericName.TypeArgumentList.Arguments.Select(x => MakeTypeName(x, semanticModel)))}>";
                }
                else
                {
                    return $"global::{typeSymbol.Symbol.ContainingNamespace}.{typeSymbol.Symbol.Name}";
                }
                
            }
        }

        private static bool IsString(string typeName) => string.Equals(typeName, "global::System.String", StringComparison.Ordinal);



        private static string MakeTupleTypeName(SemanticModel semanticModel, TupleTypeSyntax tupleType)
        {
            var builder = new StringBuilder(tupleType.Span.Length);
            builder.Append('(');
            for (int i = 0; i < tupleType.Elements.Count; i++)
            {
                var item = tupleType.Elements[i];
                builder.Append(MakeTypeName(item.Type, semanticModel));
                if (!item.Identifier.IsMissing)
                {
                    builder.Append(' ');
                    builder.Append(item.Identifier.ValueText);
                }
                if (i < tupleType.Elements.Count - 1)
                {
                    builder.Append(", ");
                }
            }
            builder.Append(')');
            return builder.ToString();
        }
    }
}
